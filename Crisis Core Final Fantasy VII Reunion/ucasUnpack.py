# Script decompressing ucas archives with help of json file generated by UnrealPakViewer.
# It was made just to understand how archives are storing data. It's slow in comparison to fully C-like tools, but it unpacks all files whole in comparison to UnrealPakViewer/umodel
# My goal is to make it working without json file so I can start working on ucas/utoc repacker
# It requires Oodle.exe in the same folder, you can compile it with Oodle.cpp in the same repo folder
# Confirmed that it's unpacking fully without issues all pakchunks
# For now it supports unpacking encrypted ucas if files uses only one 256 kB blocks

import subprocess
import json
import sys
import os
import Crypto.Cipher # pip install pycryptodome
from Crypto.Cipher import AES

def Sort(key):
	return key["Offset"]

def readString(myfile):
	chars = []
	while True:
		c = myfile.read(1)
		if c == b'\x00':
			return str(b"".join(chars).decode("UTF-8"))
		chars.append(c)

utoc_file = open(f"{sys.argv[1]}.utoc", "rb")

if (utoc_file.read(16) != b"-==--==--==--==-"):
	print("Wrong MAGIC!")
	sys.exit(1)

version = int.from_bytes(utoc_file.read(4), "little")
if (version != 3):
	print("Unsupported version: %d" % version)

header_size = int.from_bytes(utoc_file.read(4), "little")
file_count = int.from_bytes(utoc_file.read(4), "little")
all_block_count = int.from_bytes(utoc_file.read(4), "little")
block_entry_size = int.from_bytes(utoc_file.read(4), "little")
compression_method_string_id = int.from_bytes(utoc_file.read(4), "little")
compression_method_string_len = int.from_bytes(utoc_file.read(4), "little")
block_size = int.from_bytes(utoc_file.read(4), "little")
DirectoryIndexSize = int.from_bytes(utoc_file.read(4), "little")
valid_container = int.from_bytes(utoc_file.read(4), "little")
containerID = int.from_bytes(utoc_file.read(8), "little")
encryptionkeyGUID = int.from_bytes(utoc_file.read(16), "little")
flags = int.from_bytes(utoc_file.read(4), "little")
Compressed = bool(flags & (1 << 0))
Encrypted = bool(flags & (1 << 1))
Signed = bool(flags & (1 << 2))
Indexed = bool(flags & (1 << 3))

utoc_file.seek(header_size)

DATA1 = []
for i in range(file_count):
	entry = {}
	entry["file_hash"] = int.from_bytes(utoc_file.read(8), "big")
	entry["flags"] = int.from_bytes(utoc_file.read(4), "big")
	DATA1.append(entry)

#print(DATA1)

DATA2 = []
for i in range(file_count):
	entry = {}
	entry["ID"] = int(int.from_bytes(utoc_file.read(5), "big") / 0x40000)
	entry["dec_size"] = int.from_bytes(utoc_file.read(5), "big")
	DATA2.append(entry)

#print(DATA2)

DATA3 = []
for i in range(all_block_count):
	entry = {}
	offset = int.from_bytes(utoc_file.read(5), "little") 
	entry["offset"] = offset 
	entry["com_size"] = int.from_bytes(utoc_file.read(3), "little")
	entry["unc_size"] = int.from_bytes(utoc_file.read(3), "little")
	entry["com_method"] = int.from_bytes(utoc_file.read(1), "little")
	DATA3.append(entry)

#print(DATA3)

pos = utoc_file.tell()

CompressionMethod = readString(utoc_file)

if (CompressionMethod != "Oodle"):
	print("This tool doesn't support other compression methods than Oodle!")
	sys.exit()

utoc_file.close()

json_file = open(f"{sys.argv[1]}.json", "r", encoding="UTF-8")
DUMP = json.load(json_file)["Files"]
json_file.close()

DUMP.sort(key=Sort)

FilteredList = []

all_dec_size = 0

for i in range(len(DUMP)):
	print(i)
	entry = {}
	entry["filepath"] = DUMP[i]["Path"]
	entry["com_size"] = DUMP[i]["Compressed Size"]
	entry["dec_size"] = DUMP[i]["Size"]
	all_dec_size += DUMP[i]["Size"]
	entry["block_count"] = DUMP[i]["Compressed Block Count"]
	entry["Encrypted"] = bool(DUMP[i]["IsEncrypted"])
	FilteredList.append(entry)

DUMP = []

if (Encrypted == True):
	print("At least one of files is encrypted.")
	print("Provide AES key in 0x form to unpack encrypted files:")
	AES_Key = input()
	if (AES_Key[:2] != "0x"):
		print("Provided key in wrong format!")
		sys.exit(1)
	if len(AES_Key) != 66:
		print("Key has wrong length!")
		sys.exit(1)
	AES_Key = bytes.fromhex(AES_Key[2:])

print("Unpacked files will take space of: %d B, %.2f MB" % (all_dec_size, all_dec_size/1024/1024))
print("To continue, press ENTER")
input()

ucas_file = open(f"{sys.argv[1]}.ucas", "rb")

FilteredListLen = len(FilteredList)

block_number = 0

for i in range(len(FilteredList)):
	os.makedirs(os.path.dirname(FilteredList[i]["filepath"]), exist_ok=True)
	file_pos = ucas_file.tell()
	if (FilteredList[i]["block_count"] == 1):
		ucas_file.seek(DATA3[block_number]["offset"])
		if (FilteredList[i]["Encrypted"]):
			cipher = AES.new(AES_Key, AES.MODE_ECB)
			if (DATA3[block_number]["com_size"] % 0x10 != 0):
				size = DATA3[block_number]["com_size"] + (0x10 - (DATA3[block_number]["com_size"] % 0x10))
			else:
				size = DATA3[block_number]["com_size"]
			buffer = cipher.decrypt(ucas_file.read(size))
		else:
			buffer = ucas_file.read(DATA3[block_number]["com_size"])
		print("File: %6d/%d  %s" % (i+1, FilteredListLen, FilteredList[i]["filepath"]))
		oodle_magic = int.from_bytes(buffer[0:1], "big")
		oodle_compressor = int.from_bytes(buffer[1:2], "big") #idk, just guessing what this is
		if (oodle_magic != 0x8C or oodle_compressor > 0x10):
			temp_file = open(FilteredList[i]["filepath"], "wb")
			temp_file.write(buffer[0:FilteredList[i]["dec_size"]])
			temp_file.close()
			continue
		catch = subprocess.run(["Oodle.exe", "-d", "%d" % DATA3[block_number]["unc_size"], "stdin=%d" % DATA3[block_number]["com_size"], FilteredList[i]["filepath"]], input=buffer, capture_output=True, text=False)
		if (catch.stderr != b""):
			print(buffer.hex())
			print(catch.stderr.decode("ascii"))
			print("Error while decompressing file at offset: 0x%X!" % file_pos)
			os.remove(FilteredList[i]["filepath"])
			if (os.path.exists("temp.oodle") == True):
				os.remove("temp.oodle")
			sys.exit(1)
		block_number += 1
		
	else:
		print("File: %6d/%d  %s, size: %.2f MB" % (i+1, FilteredListLen, FilteredList[i]["filepath"], FilteredList[i]["dec_size"]/1024/1024))
		chunks = []
		for x in range(FilteredList[i]["block_count"]):
			print("Chunk: %d/%d" % (x+1, FilteredList[i]["block_count"]), end="\r")
			if (ucas_file.tell() % 0x10 != 0):
				ucas_file.seek(ucas_file.tell() + 0x10 - (ucas_file.tell() % 0x10))
			oodle_magic = int.from_bytes(ucas_file.read(1), "big")
			oodle_compressor = int.from_bytes(ucas_file.read(1), "big") #idk, just guessing what this is
			if (oodle_magic != 0x8C or oodle_compressor > 0x10):
				ucas_file.seek(-2, 1)
				if (x+1 < FilteredList[i]["block_count"]):
					chunks.append(ucas_file.read(262144))
				else:
					chunks.append(ucas_file.read(FilteredList[i]["dec_size"] - (x * 262144)))
				continue
			block_size = int.from_bytes(ucas_file.read(3), "big") + 6
			flag = int.from_bytes(ucas_file.read(1), "big")
			ucas_file.seek(-6, 1)
			chunk_pos = ucas_file.tell()
			if (flag != 0):
				bytedata = ucas_file.read(block_size)
			else:
				bytedata = ucas_file.read(6)
			if (x+1 < FilteredList[i]["block_count"]):
				catch = subprocess.run(["Oodle.exe", "-d", "262144", "stdin=%d" % len(bytedata), "stdout"], input=bytedata, capture_output=True, text=False)
				if (catch.stderr != b""):
					print(catch.stderr.decode("ascii"))
					print("Chunk: %d/%d" % (x+1, FilteredList[i]["block_count"]))
					print("Error while decompressing chunk at offset: 0x%X!" % chunk_pos)
					print("File offset: 0x%X" % file_pos)
					sys.exit(1)
			else:  
				catch = subprocess.run(["Oodle.exe", "-d", "%d" % (FilteredList[i]["dec_size"] - (x * 262144)), "stdin=%d" % len(bytedata), "stdout"], input=bytedata, capture_output=True, text=False)
				if (catch.stderr != b""):
					print(catch.stderr.decode("ascii"))
					print("Chunk: %d/%d" % (x+1, FilteredList[i]["block_count"]))
					print("Error while decompressing chunk at offset: 0x%X!" % chunk_pos)
					print("File offset: 0x%X" % file_pos)
					sys.exit(1)
			chunks.append(catch.stdout)
		conc_file = open(FilteredList[i]["filepath"], "wb")
		conc_file.write(b"".join(chunks))
		end_size = conc_file.tell()
		conc_file.close()
		if (end_size != FilteredList[i]["dec_size"]):
			print("Decompressed file has wrong size!")
			print("Expected: %dB" % FilteredList[i]["dec_size"])
			print("Got: %dB" % end_size)
			os.remove(FilteredList[i]["filepath"])
			sys.exit(1)

ucas_file.close()
